import _slicedToArray from "@babel/runtime/helpers/esm/slicedToArray";
import _typeof from "@babel/runtime/helpers/esm/typeof";
import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";
import _toConsumableArray from "@babel/runtime/helpers/esm/toConsumableArray";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

import React, { useState, useRef, useMemo, useCallback, useEffect } from 'react';
import { View } from 'remax/one';
import classNames from 'classnames';
import { createSelectorQuery } from '../one';
import { throttle, guid } from '../_util';
import { getPrefixCls } from '../common';
var prefixCls = getPrefixCls('swiper');

var getChildrenNode = function getChildrenNode(children) {
  var _childrenNode;

  var childrenArray = React.Children.toArray(children);

  if (childrenArray.length <= 1) {
    return childrenArray;
  }

  var childrenNode = _toConsumableArray(childrenArray);

  childrenNode.unshift(childrenArray[childrenArray.length - 1]);
  childrenNode.push(childrenArray[0]);
  childrenNode = (_childrenNode = childrenNode) === null || _childrenNode === void 0 ? void 0 : _childrenNode.map(function (child, index) {
    return _objectSpread(_objectSpread({}, child), {}, {
      key: '.' + index
    });
  });
  return childrenNode;
};

var getIndicatorsNode = function getIndicatorsNode(num, current, position, color, style, look) {
  var defaultColor = undefined;
  var activeColor = undefined;

  if (Array.isArray(color)) {
    if (color[0] && typeof color[0] === 'string') {
      activeColor = color[0];
    }

    if (color[1] && typeof color[1] === 'string') {
      defaultColor = color[1];
    }
  }

  if (look === 'dark') {
    activeColor = '#000';
    defaultColor = 'rgba(0, 0, 0, 0.13)';
  }

  if (look === 'anna') {
    activeColor = '#ff7777';
    defaultColor = 'rgba(255, 119, 119, 0.2)';
  }

  var defaultStyle = {};
  var activeStyle = {};

  if (Array.isArray(style)) {
    if (style[0] && _typeof(style[0]) === 'object') {
      activeStyle = style[0];
    }

    if (style[1] && _typeof(style[1]) === 'object') {
      defaultStyle = style[1];
    }
  }

  var activeIndex = current - 1;

  if (current === 1) {
    activeIndex = 0;
  }

  if (current === 0) {
    activeIndex = num - 1;
  }

  if (current > num) {
    activeIndex = 0;
  }

  var indicators = _toConsumableArray(new Array(num).keys());

  var indicatorsNode = indicators.map(function (i) {
    var _classNames;

    var indicatorStyle = Object.assign({}, activeIndex === i ? activeStyle : defaultStyle, {
      backgroundColor: activeIndex === i ? activeColor : defaultColor
    });
    return /*#__PURE__*/React.createElement(View, {
      key: i,
      className: classNames("".concat(prefixCls, "-indicator"), (_classNames = {}, _defineProperty(_classNames, "".concat(prefixCls, "-indicator-").concat(position), position), _defineProperty(_classNames, "".concat(prefixCls, "-indicator-active"), activeIndex === i), _classNames)),
      style: indicatorStyle
    });
  });
  return indicatorsNode;
};

var InternalSwiper = function InternalSwiper(props) {
  var _classNames2;

  var autoplay = props.autoplay,
      _props$autoplayInterv = props.autoplayInterval,
      autoplayInterval = _props$autoplayInterv === void 0 ? 3000 : _props$autoplayInterv,
      _props$duration = props.duration,
      duration = _props$duration === void 0 ? 300 : _props$duration,
      _props$shape = props.shape,
      shape = _props$shape === void 0 ? 'square' : _props$shape,
      size = props.size,
      height = props.height,
      vertical = props.vertical,
      _props$curve = props.curve,
      curve = _props$curve === void 0 ? 'ease' : _props$curve,
      _props$showIndicators = props.showIndicators,
      showIndicators = _props$showIndicators === void 0 ? true : _props$showIndicators,
      _props$indicatorLook = props.indicatorLook,
      indicatorLook = _props$indicatorLook === void 0 ? 'light' : _props$indicatorLook,
      indicatorColor = props.indicatorColor,
      indicatorStyle = props.indicatorStyle,
      _props$indicatorPosit = props.indicatorPosition,
      indicatorPosition = _props$indicatorPosit === void 0 ? vertical ? 'right' : 'bottom' : _props$indicatorPosit,
      style = props.style,
      children = props.children; // Make Special treatment when the number of childNodes is 1

  var childrenArray = useMemo(function () {
    return React.Children.toArray(children);
  }, [children]);
  var startPoint = useRef(0);
  var startTime = useRef(0);
  var sideLength = useRef(0);
  var swiperId = useRef(guid());
  var swiperWidth = useRef(0);
  var swiperHeight = useRef(0);
  var swiperItemIndex = useRef(childrenArray.length > 1 ? 1 : 0);
  var origin = useRef(0);
  var intervalId = useRef(null);

  var _useState = useState(0),
      _useState2 = _slicedToArray(_useState, 2),
      distance = _useState2[0],
      setDistance = _useState2[1];

  var _useState3 = useState('none'),
      _useState4 = _slicedToArray(_useState3, 2),
      transition = _useState4[0],
      setTransition = _useState4[1];

  useEffect(function () {
    var getSwiperWidth = function getSwiperWidth() {
      createSelectorQuery() // @ts-ignore
      .select(".".concat(prefixCls, "-id-").concat(swiperId.current)).boundingClientRect().exec(function (rect) {
        var node = Array.isArray(rect) ? rect === null || rect === void 0 ? void 0 : rect[0] : rect;
        swiperWidth.current = node === null || node === void 0 ? void 0 : node.width;
        swiperHeight.current = node === null || node === void 0 ? void 0 : node.height;

        if (vertical) {
          sideLength.current = node === null || node === void 0 ? void 0 : node.height;
        } else {
          sideLength.current = node === null || node === void 0 ? void 0 : node.width;
        }

        if (childrenArray.length > 1) {
          origin.current = -sideLength.current;
          setDistance(origin.current);
        }
      });
    };

    getSwiperWidth();
    return function () {
      clearInterval(intervalId.current);
    };
  }, []); // Seamless switching

  useEffect(function () {
    // if (distance !== (childrenArray.length + 1) * -sideLength.current) {
    //   return;
    // }
    if (swiperItemIndex.current === 0) {
      setTimeout(function () {
        swiperItemIndex.current = childrenArray.length;
        origin.current = swiperItemIndex.current * -sideLength.current;
        setDistance(origin.current);
        setTransition('none');
      }, duration); // Extend 300ms and set the transition to none
    }

    if (swiperItemIndex.current > childrenArray.length) {
      setTimeout(function () {
        swiperItemIndex.current = 1;
        origin.current = swiperItemIndex.current * -sideLength.current;
        setDistance(origin.current);
        setTransition('none');
      }, duration); // Extend 300ms and set the transition to none
    }
  }, [swiperItemIndex.current, duration, distance]); // move

  var move = useCallback(function (direction) {
    if (direction === 'left') {
      swiperItemIndex.current = swiperItemIndex.current + 1;
    }

    if (direction === 'right') {
      swiperItemIndex.current = swiperItemIndex.current - 1;
    }

    origin.current = swiperItemIndex.current * -sideLength.current;
    setDistance(origin.current);
    setTransition("all ".concat(duration / 1000, "s ").concat(curve));
  }, [swiperItemIndex.current, sideLength.current, duration]); // control autoplay

  var controlAutoplay = useCallback(function (action) {
    if (action === 'start') {
      if (autoplay && !intervalId.current) {
        intervalId.current = setInterval(function () {
          move('left');
        }, autoplayInterval);
      }
    }

    if (action === 'stop') {
      if (intervalId.current) {
        clearInterval(intervalId.current);
        intervalId.current = null;
      }
    }
  }, [autoplay, autoplayInterval, intervalId.current]); // autoplay

  useEffect(function () {
    if (!autoplay) {
      controlAutoplay('stop');
    }

    if (intervalId.current) {
      return;
    }

    if (autoplay) {
      controlAutoplay('start');
    }
  }, [autoplay, intervalId.current]);
  var throttleTouchMove = useCallback(throttle(function (e) {
    var touch = e.touches[0];
    var diff = (vertical ? touch.pageY : touch.pageX) - startPoint.current;
    var currDistance = diff + origin.current;

    if (currDistance) {
      setDistance(currDistance);
      setTransition('none');
    }
  }, 10, {
    trailing: false
  }), [startPoint.current, origin.current]);

  var handleTouchStart = function handleTouchStart(e) {
    if (childrenArray.length <= 1) {
      return;
    }

    controlAutoplay('stop');
    var touch = e.touches[0];
    startPoint.current = vertical ? touch.pageY : touch.pageX;
    startTime.current = Date.now();
  };

  var handleTouchMove = function handleTouchMove(e) {
    if (childrenArray.length <= 1) {
      return;
    } // @ts-ignore


    throttleTouchMove(e);
  };

  var handleTouchEnd = function handleTouchEnd(e) {
    if (childrenArray.length <= 1) {
      return;
    }

    var touch = e.changedTouches[0] || e.nativeEvent.changedTouches[0];
    var diff = (vertical ? touch.pageY : touch.pageX) - startPoint.current;
    var speed = diff / (Date.now() - startTime.current);
    var harfSideLength = sideLength.current / 2;
    console.log('speed', speed);

    if (Math.abs(speed) > 0.3) {
      if (diff > 0) {
        move('right');
      }

      if (diff < 0) {
        move('left');
      }
    } else if (harfSideLength < Math.abs(diff)) {
      if (diff > 0) {
        move('right');
      }

      if (diff < 0) {
        move('left');
      }
    } else {
      move();
    }

    controlAutoplay('start');
  };

  var handleTouchCancel = function handleTouchCancel() {
    if (childrenArray.length <= 1) {
      return;
    }

    move();
  };

  var childrenNode = useMemo(function () {
    return getChildrenNode(children);
  }, [children]);
  var indicatorsNode = useMemo(function () {
    return getIndicatorsNode(childrenArray.length, swiperItemIndex.current, indicatorPosition, indicatorColor, indicatorStyle, indicatorLook);
  }, [childrenArray.length, swiperItemIndex.current, indicatorPosition, indicatorColor, indicatorStyle, indicatorLook]);
  var classes = classNames(prefixCls, (_classNames2 = {}, _defineProperty(_classNames2, "".concat(prefixCls, "-id-").concat(swiperId.current), true), _defineProperty(_classNames2, "".concat(prefixCls, "-").concat(shape), shape), _defineProperty(_classNames2, "".concat(prefixCls, "-").concat(size), size), _classNames2));
  return /*#__PURE__*/React.createElement(View, {
    className: classes,
    style: _objectSpread(_objectSpread({}, style), {}, {
      height: height,
      borderRadius: shape === 'round' ? swiperHeight.current : undefined
    })
  }, /*#__PURE__*/React.createElement(View, {
    className: classNames("".concat(prefixCls, "-track"), _defineProperty({}, "".concat(prefixCls, "-track-vertical"), vertical)),
    onTouchStart: handleTouchStart,
    onTouchMove: handleTouchMove,
    onTouchEnd: handleTouchEnd,
    onTouchCancel: handleTouchCancel,
    style: {
      transform: "translate3d(".concat(vertical ? '0, ' + distance + 'PX' : distance + 'PX, 0', ", 0)"),
      transition: transition
    }
  }, childrenNode), showIndicators ? /*#__PURE__*/React.createElement(View, {
    className: classNames("".concat(prefixCls, "-indicators"), _defineProperty({}, "".concat(prefixCls, "-indicators-").concat(indicatorPosition), indicatorPosition))
  }, indicatorsNode) : null);
};

export default InternalSwiper;