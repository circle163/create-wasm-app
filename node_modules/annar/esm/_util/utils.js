import _typeof from "@babel/runtime/helpers/esm/typeof";
import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

export var guid = function guid() {
  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
    var r = Math.random() * 16 | 0;
    var v = c == 'x' ? r : r & 0x3 | 0x8;
    return v.toString(16);
  });
}; // 如果你想禁用第一次首先执行的话，传递{leading: false}，还有如果你想禁用最后一次执行的话，传递{trailing: false}。
// 默认是 第一次首先执行并且最后一次会执行，相当于 {leading: true, trailing: true}

export var throttle = function throttle(func, wait, options) {
  var previous = 0;
  var timeout = null;
  var context;
  var args;
  if (!options) options = {};

  var later = function later() {
    previous = options.leading === false ? 0 : new Date().getTime();
    timeout = null;
    func.apply(context, args);
    if (!timeout) context = args = null;
  };

  var throttled = function throttled() {
    var now = new Date().getTime();
    if (!previous && options.leading === false) previous = now;
    var remaining = wait - (now - previous);
    context = this; // eslint-disable-next-line prefer-rest-params

    args = arguments;

    if (remaining <= 0 || remaining > wait) {
      if (timeout) {
        clearTimeout(timeout);
        timeout = null;
      }

      previous = now;
      func.apply(context, args);
      if (!timeout) context = args = null;
    } else if (!timeout && options.trailing !== false) {
      timeout = setTimeout(later, remaining);
    }
  };

  return throttled;
};
export var mergeStyle = function mergeStyle(target, style) {
  var newTarget = target ? _objectSpread({}, target) : {};

  for (var _key in style) {
    if (Object.prototype.hasOwnProperty.call(style, _key)) {
      var element = style[_key];

      if (element || element === 0) {
        newTarget[_key] = element;
      }
    }
  }

  return newTarget;
};
export var twoDimensional = function twoDimensional(data, columns, span) {
  var standard = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 24;
  var two = [];
  var spanTwo = [];
  var colSpan = standard / columns;

  if (!Array.isArray(data)) {
    return [two, spanTwo];
  }

  var spanArray = [];

  if (span) {
    spanArray = new Array(data.length).fill(colSpan);

    if (typeof span === 'number') {
      if (span > 0) {
        spanArray[0] = span;
      }

      if (span < 0) {
        spanArray[data.length - 1] = Math.abs(span);
      }
    }

    if (Array.isArray(span)) {
      spanArray = span.concat(spanArray.slice(span.length));
    }

    var prev = 0;
    var rowIndex = 0;

    for (var i = 0; i < spanArray.length; i++) {
      var item = spanArray[i];
      var row = [data[i]];
      var spanRow = [item];

      if (item >= 24) {
        rowIndex = two.push(row);
        spanTwo.push(spanRow);
      } else {
        if (24 - prev >= item) {
          two[rowIndex] ? two[rowIndex] = two[rowIndex].concat(data[i]) : rowIndex = two.push(row) - 1;
          spanTwo[rowIndex] ? spanTwo[rowIndex] = spanTwo[rowIndex].concat(item) : rowIndex = spanTwo.push(spanRow) - 1;
          prev += item;
        } else {
          rowIndex = two.push(row) - 1;
          spanTwo.push(spanRow);
          prev = item;
        }
      }
    }

    return [two, spanTwo];
  }

  var rowsLength = Math.ceil(data.length / columns);
  var oneDimensional = data.concat([]);
  var index = 0;

  for (var _i = 0; _i < rowsLength; _i++) {
    var _row = oneDimensional.slice(index, index += columns);

    two.push(_row);
    spanTwo.push(new Array(_row.length).fill(colSpan));
  }

  return [two, spanTwo];
};
export var flat = function flat(arr) {
  if (!Array.isArray(arr)) {
    return [];
  }

  return arr.reduce(function (prev, curr) {
    if (Array.isArray(curr)) {
      return prev.concat(flat(curr));
    }

    return prev.concat(curr);
  }, []);
};
export var isObjectValueEqual = function isObjectValueEqual(a, b) {
  //取对象a和b的属性名
  var aProps = Object.getOwnPropertyNames(a);
  var bProps = Object.getOwnPropertyNames(b); //判断属性名的length是否一致

  if (aProps.length != bProps.length) {
    return false;
  } //循环取出属性名，再判断属性值是否一致


  for (var i = 0; i < aProps.length; i++) {
    var propName = aProps[i];

    if (a[propName] !== b[propName]) {
      return false;
    }
  }

  return true;
};
export var isArrayValueEqual = function isArrayValueEqual(a, b) {
  if (!Array.isArray(a) || !Array.isArray(b)) {
    return false;
  } //判断array的length是否一致


  if (a.length != b.length) {
    return false;
  }

  var isEqual = true;

  for (var i = 0; i < a.length; i += 1) {
    if (_typeof(a[i]) === 'object' && _typeof(b[i]) === 'object') {
      !isObjectValueEqual(a[i], b[i]) && (isEqual = false);
    } else {
      a[i] !== b[i] && (isEqual = false);
    }
  }

  return isEqual;
};
export var deepClone = function deepClone(data) {
  var cloneData = null;

  if (Array.isArray(data)) {
    cloneData = [];

    for (var i = 0; i < data.length; i += 1) {
      var item = data[i];
      cloneData[i] = deepClone(item);
    }
  } else if (_typeof(data) === 'object' && data !== null) {
    cloneData = {};
    Object.keys(data).forEach(function (key) {
      var item = data[key];
      cloneData[key] = deepClone(item);
    });
  } else {
    cloneData = data;
  }

  return cloneData;
};